## Урок: конвертеры url-путей в Django
(черновик, количество заданий минимально)

#### Задача автора: 
Разработать вариант урока по решению прикладной задачи: работа с путями в джанго (такая, где в путях есть дата).  
(зачем нам эти даты, к какому типу приводить, и формат дат тоже не уточняется. 
возможно, преполагается работа с путями и конверторами, просто это не свормулированно в задании явно. к тому же, нет требований по размеру или длительности урока, только "кратко и понятно", это 5 минут? или 25? ок, сделаем лаконичным.)  
Содержание -- Теория: проблема, решение, лучшие практики. Пример одной задачи с решением. Пример одного квиза с ответами. Примеры с подсказками.

#### Целевая аудитория: 
студент, недавно познакомившийся с Python. 
Умеет создавать при помощи Django простые приложения с динамическими страницами на базе шаблонов.
(наверное, предполагается что студент уже знает про url-пути и как идет их обрабтка в современных веб-фреймворках, 
но т.к. я не видел предыдущих уроков, а это напрямую относится к теме, лучше сказать пару слов)

#### Применимость: 
Python 3.4+, Django 2+ (там появились конвертеры, сейчас 4.2 требующая 3.8+).

---

### Теоретическая часть:

Современные пайтон веб-фреймворки (django, flask, aiohttp, fastapi, etc.) для бекенда 
строят обработку входящих http запросов на анлизе url-пути запроса (path).
Ищут его в списке зарегистрированных путей (маршрутов, так их часто называют со стороны сервера),
и вызов соответвующей функции-обработчика (в джанго они называются views).

Пути запросов и обработчики сопоставляются следующим образом:  
```Python
# urls.py
from django.urls import path, re_path

from . import views

urlpatterns = [
    path("archive/2003/", views.special_case_2003),
    path("archive/<year>/", views.year_archive, name='process_year_archive_request'),
    path("archive/<str:year>/", views.year_archive, name='this_route_is_the_same_as_above'),
    path("archive/<int:year>-<int:month>/", views.month_archive),
    re_path(r"^archive/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$", views.month_archive),
]
```

Часть пути можно указать как параметр (переменную), затем автоматически распознать (захватить) и конвертировать в нужный тип данных, 
для чего используются конвертеры путей [1]. Далее захваченные параметры передаются как аргументы в функцию обработчика. 
Все зарегистрированные пути проверяются по очереди, и если конвертер опознал часть пути по указанному regex, 
но не смог выполнить преобразование, он должен поднять ValueError, 
которая будет отловлена системой django, в таком случае система перейдет к проверке следующего варианта пути.

> Параметры пути не относятся к стандарту URL, в отличие от параметров url (query), которые обычно указываются после пути в виде `?key1=value1&key2=value2`

Пример создания и регистрации нового конвертера:
```Python
# converters.py
class FourDigitYearConverter:
    regex = "[0-9]{4}"

    def to_python(self, value):
        return int(value)

    def to_url(self, value):
        return "%04d" % value

# urls.py
from django.urls import path, register_converter

from . import views, converters

register_converter(converters.FourDigitYearConverter, "yyyy")

urlpatterns = [
    path("archive/<yyyy:year>/", views.year_archive),
]
```

В интерфейсе класса конвертера названия `regex`, `to_python` и `to_url` являются обязательными ключевыми словами.  
Исходный код конвертеров обычно располагается в отдельном файле, а регистрация конверторов проводится там же где и регистрация путей. 
При этом имя, под которым регистрируется конвертер, используется в шаблоне пути в угловых скобках через двоеточие перед именем параметра 
(иногда это выглядит как тип данных, но не является типом. конвертер по умочанию `str`).

> Таким образом, основная задача конвертеров -- распознать путь (маршрут), чтобы вызвать его обработчик, 
> и передать туда параметры пути в удобном для дальнейшей работы виде.
> Не следует в конвертере решать задачи обработчика, например пытаться поднять другие типы ошибок и или реализовать логику не относящуюся к преобразованию типов.

#### Применение конвертеров.
Допустим, в пути в качестве параметра используется дата. В джанго нет готовых конвереров для дат, поэтому задача распознания и преобразования такого параметра или пути может стать актуальной. Как её решить? Для начала ответить на вопросы "зачем нам нужна дата?", "в каком формате она приходит?", "к какому типу данных её удобнее преобразовать?". Например, могут возникнуть такие ситуации:

- Возможно, дату следует оставить строкой. Может это просто название директории в архиве со статическим контентом. Но если не будет проверки формата, следует убедиться что этот url путь нельзя перепутать с другими. А ещё подумать о безопасности: может кто-то так получит не авторизованный доступ к ресурсам, введя вместо даты путь к каталогу с системными файлами или конфиденциальной информацией.
- Если дату определенного формата из цифр надо преобразовать в целые числа и разделить на части, можно использовать встроенный `int` конвертер. Что, опять же, не застрахует от вызова обработчика для чисел неправильного диапазона. Впрочем, если вместо "not found" мы хотим вызвать обработчик и сообщить о неверном формате, то этот вариант может подойти.
- В некоторых случаях мы можем передать в обработчик слегка отфильтрованные строки, тогда можно использовтаь пути со встроенными regex параметрами, например `(?P<year>[0-9]{4})` пропустит только 4-значные натуральные числа (или 4-ре нуля), оставив их строкой. (в этом варианте весь путь указывается как регулярное выражение `r"^.../.../$"` и регистрируется как `re_path` вместо `path` объекта).
- Хорошим вариантом представляется специальный конвертер, который попробует преобразовать дату известного формата в datetime объект, с которым удобно работать в дальнейшем, в том чиле преобразовать к другому формату и выполнять сравнения и вычисления дат.
- Может так получится, что дату вовсе не следует передавать как часть пути, а лучше сделать параметром url query или добавить в json payload.


#### Литература:
[1] [Официальная документация (на английском)](https://docs.djangoproject.com/en/4.2/topics/http/urls/#path-converters)  
[2] [Довольно хорошая статья с примерами (на русском)](https://habr.com/ru/companies/yandex_praktikum/articles/541068/)

---


### Практическая задача:

- текст условия:  

Напишите код конвертора строки формата `'%Y-%m-%d'` в объект datetime.
Напишите код обработчика запросов который разрешает обработку дат начиная с 1900 года.
Расположите код конвертера и обработчика в том же файле, где производится регистраия маршрутов,  
и зарегистрируйте произвольный маршрут, использующий их.  

- прекод:  
```Python
from datetime import datetime
from django.urls import path, register_converter
from django.http import HttpResponse, HttpResponseNotFound


class DateConverter:
    regex = None

    def to_python(self, value):
        return

    def to_url(self, value):
        return


def process_dated_archive(request, date: datetime):
    return
```

- текст подсказки:  
```Python
# 1: regex = "[0-9]{4}-[0-9]{2}-[0-9]{2}"
# 2: format = '%Y-%m-%d'
# 3: return datetime.strptime(value, self.format)
# 4: return value.strftime(self.format)
# 5: if date >= datetime(1900,1,1):
# 6: register_converter(DateConverter, "datetime")
# 7: path("archive/<datetime:date>/", process_dated_archive),
```

- код авторского решения:  
```Python
# urls.py
from datetime import datetime
from django.urls import path, register_converter
from django.http import HttpResponse, HttpResponseNotFound


class DateConverter:
    regex = "[0-9]{4}-[0-9]{2}-[0-9]{2}"
    format = '%Y-%m-%d'

    def to_python(self, value: str) -> datetime:
        return datetime.strptime(value, self.format)

    def to_url(self, value: datetime) -> str:
        return value.strftime(self.format)


def process_dated_archive(request, date: datetime):
    if date >= datetime(1900,1,1):
        return HttpResponse("<h1>Page was found</h1>")
    else:
        return HttpResponseNotFound("<h1>Page not found</h1>")


register_converter(DateConverter, "datetime")

urlpatterns = [
    path("archive/<datetime:date>/", process_dated_archive, name="process_dated_archive_request"),
]
```

- текст сообщения, которое увидит студент после удачного решения задачи.  

Успех! Обратите внимание, что код логики обработки дат отделен от кода преобразования. Зачастую, в правльном выделении зон ответсвенности для исполнителей заключается ключ к успеху.

### Квиз:
(на понимание студентом теории из урока)

Q: что будет происходить если попробовать зарегистрировать два одинаковых маршрута?  
A1: будет вызван обработчик для первого маршрута в списке  
C1: верно. проверка первого маршрута окажется успешной, и до второго дело не дойдет.  
A2: будет вызван обработчик для второго маршрута в списке  
C2: не верно. маршруты не перезаписывают друг друга, а сохранюятся в порядке регистрации, и проверяются по очереди.  
A3: будут вызваны оба обработчика по очереди.  
C3: не верно. на каждый запрос вызывается только один обработчик, указанный в первом совпавшем маршруте.  
A4: будет поднята ошибка о том что зарегистрированный маршрут уже есть в списке.  
C4: не верно. маршруты не проверяются при регистрации.  

Q: в какой из строк больше всего обязательных для кастомного конвертера ключевых слов?  
A1: `\_\_init\_\_`,  `to_python`, `to_url`,  `value`.  
C1: не верно. два обязательных кл.слова -- `to_python` и `to_url`. два не обязательных -- `\_\_init\_\_` и `value`.  
A2: `regex`, `to_python`, `to_url`, `filter`.  
C2: верно. три обязательных кл.слова -- `regex`, `to_python` и `to_url`. одно не обязательное -- `filter`.  
A3: `regex`, `to_python`, `value`, `ValueError`  
C3: не верно. два обязательных кл.слова -- `regex` и `to_python`. два не обязательных -- `value` и `ValueError`.  
A4: `\_\_init\_\_`, `self`, `return`, `ValueError`.  
C4: не верно. два обязательных кл.слова -- `self` и `return`. два не обязательных -- `\_\_init\_\_` и `ValueError`.  

Q: какие какие типы ошибок можно поднимать в конвертере для продолжения исполнения программы?  
A1: `ValueError`  
C1: верно. `ValueError` из конвертера или его подпрограмм отправляет программу к проверке следующего маршрута.  
A2: `ValueError` и `AttributeError`   
C2: не верно. поднятие `AttributeError` приведет к остановке программы.  
A3: `HttpResponseNotFound`  
C3: не верно. `HttpResponseNotFound` это вариант http-ответа, который может вызываться в обработчике, но не в конвертере.   
A4: никаких  
C4: не верно. `ValueError` из конвертера или его подпрограмм отправляет программу к проверке следующего маршрута.  

Q: как используется свойство regex в классе конвертера?  
A1: проверяет соответсвие подстроки выражению перед выполнением конверсии.  
C1: верно. для начала конверсии `to_python` подстрока должна соответсвовать регулярному выражением.  
A2: проверяет соответсвие подстроки выражению после выполнением конверсии.  
C2: не верно. регулярное выражение используется до начала конверсии `to_python`.  
A3: проверяет есть ли во всем url-пути подстроки, соотвествующие выражению.  
C3: не верно. регулярное выражение применяется только к подстроке (части пути), которая подлежит конверсии.  
A4: не используется.  
C4: не верно. для начала конверсии `to_python` подстрока должна соответсвовать регулярному выражением.  

Q: какой конвертер используется по умолчанию?  
A1: накакого. будет ошибка конверсии.  
C1: не верно. конвертер по умолчанию соответсвет не пустой строке без разделителей пути.  
A2: слаг (slug) конвертер, пропускающий только буквы, цифры и дефис (`'[-a-zA-Z0-9_]+'`)   
C2: не верно. слаг-кнвертер один из стандартных, но не используется по умолчанию.  
A3: никакого, любая строка будет принята, регулярное выражение `'.+'`.  
C3: не верно. регулярное это выражение обозначает любую не пустую строку и соответсвует path конвертеру, который хоть и является стандартным, но не используется по умолчанию.  
A4: конвертер строк с регулярным выражением вида `'[^/]+'`.  
C4: верно. как значение параметра пропускается любая не пустая строка без разделителей пути.  

Q: какой вопрос следует задать в числе первых для рационализации постановки и решения задачи?  
A1: накакого. всегда и так понятно что делать, а много думать не полезно.  
C1: не верно. всегда можно что-то сделать, но зачем делать то что-то не понимая контекста?  
A2: "что делать?" -- ведь именно на этот вопрос хочтеся получить ответ.  
C2: не верно. любой программист и инженер (а особенно руководитель) должен уметь сам расставлять цели и приоритеты, а для этого понимать зачем оно делается и кому нужно.  
A3: "зачем?" -- таким вопросом можно выяснить контекст с точки зрения логики.  
C3: верно. рациональный подход не единственный, но любая техническая система состоит из частей, которые выполняют строго свои функции, тогда они выполняют их хорошо.  
A4: "какова цена?" -- разве это не самый полезный вопрос?  
C4: не верно. конечно, оценку и распределение ресурсов всегда стоит учитывать, но только понимание целей из контекста придает им ценность и приоритеты.  

Q: сколько конвертеров, обработчиков и маршрутов можно сопоставить одним обектом path или re_path?  
A1: 1-1-1. (только один к одному)  
C1: не верно. хоть конвертеры и используются чтобы определить маршрут, но их количество никак не связано с количеством маршрутов.  
A2: N-N-N. (одной записью можно зарегистрировать произвольное количество элементов каждого вида)  
C2: не верно. число обработчиков не связано с числом маршрутов, и каждому маршруту назначается один обработчик.   
A3: O\*N-1-N. (только один обработчик, не менее одного маршрута, и пропорциональное количествоу маршрутов число конвертеров)  
C3: не верно. число обработчиков не связано с числом маршрутов, и каждому маршруту назначается один обработчик.  
A4: N-1-1. (много конвертеров, один маршрут и один обработчик)  
C4: верно. каждому маршруту назначается только один обработчик, и произвольное число конвертеров может участвовать в распознании маршрута.  

Q: каковы оснавные задачи конвертеров?  
A1: распознать маршрут и передать параметры в обработчик.   
C1: не верно. хоть конвертер и участвует в распонании маршрута, но также выполняет преобразование типа. а параметры в обработчик передает надсистема.  
A2: распознать маршрут и привести данные к нужному типу.   
C2: верно. конвертер участвует в распонании маршрута и выполняет преобразование типа.
A3: привести данные к нужному типу.   
C3: не верно. конвертер не только выполняет преобразование типа, но и участвует в распонании маршрута.  
A4: вызвать правильный обработчик.  
C4: не верно. вызовом обработчика занимается надсистема.  

Q: какие из перечисленных проблем не являются специфичными для функциональности конвертора строк в даты?  
A1: запрещенные символы в подстроке.  
C1: не верно. ответсвенность конвертера проверить валидность срок: не все символы рарешены для записи дат, обычно только числа и имена месяцев и дней недели.  
A2: числовые значения, не использующиеся в датах.   
C2: не верно. ответсвенность конвертера проверить валидность чисел: не все числа могут быть использованы, обычно только некоторые диапазоны натуральных чисел.  
A3: числовые значения, не соответсвующие реальным датам.   
C3: не верно. ответсвенность конвертера проверить валидность дат: не все числа относятся к реальным датам, например 29 и 31 дни есть не в каждом месяце.  
A4: уязвимости системы через использование строковых дат.  
C4: верно. возможные уязвимости системы при использованию строк являются проблемой небезопасной архитектуры, и не относится к функциональным проблемам конвертора.  
