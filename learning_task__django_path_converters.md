## Урок: конвертеры url-путей в Django
(черновик, количество заданий минимально)

#### Задача автора: 
Разработать вариант урока по решению прикладной задачи: работа с путями в джанго (такая, где в путях есть дата).  
(зачем нам эти даты, к какому типу приводить, и формат дат тоже не уточняется. 
возможно, преполагается работа с путями и конверторами, просто это не свормулированно в задании явно. к тому же, нет требований по размеру или длительности урока, только "кратко и понятно", это 5 минут? или 25? ок, сделаем лаконичным.)  
Содержание -- Теория: проблема, решение, лучшие практики. Пример одной задачи с решением. Пример одного квиза с ответами. Примеры с подсказками.

#### Целевая аудитория: 
студент, недавно познакомившийся с Python. 
Умеет создавать при помощи Django простые приложения с динамическими страницами на базе шаблонов.
(наверное, предполагается что студент знает уже про url-пути и как идет их обрабтка в современных веб-фреймворках, 
но т.к. я не видел предыдущих уроков, а это напрямую относится к теме, лучше сказать пару слов)

#### Применимость: 
Python 3.4+, Django 2+ (там появились конвертеры, сейчас 4.2 требующая 3.8+).

---

### Теоретическая часть:

Современные пайтон веб-фреймворки (django, flask, aiohttp, fastapi, etc.) для бекенда 
строят обработку входящих http запросов на анлизе url-пути запроса (path).
Ищут его в списке зарегистрированных путей (маршрутов, так их часто называют со стороны сервера),
и вызов соответвующей функции-обработчика (в джанго они называются views).

Пути запросов и обработчики сопоставляются следующим образом:  
```Python
# urls.py
from django.urls import path, re_path

from . import views

urlpatterns = [
    path("archive/2003/", views.special_case_2003),
    path("archive/<year>/", views.year_archive, name='process_year_archive_request'),
    path("archive/<str:year>/", views.year_archive, name='this_route_is_the_same_as_above'),
    path("archive/<int:year>-<int:month>/", views.month_archive),
    re_path(r"^archive/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$", views.month_archive),
]
```

Часть пути можно указать как параметр (переменную), затем автоматически распознать (захватить) и конвертировать в нужный тип данных, 
для чего используются конвертеры путей [1]. Далее захваченные параметры передаются как аргументы в функцию обработчика. 
Все зарегистрированные пути проверяются по очереди, и если конвертер опознал часть пути по указанному regex, 
но не смог выполнить преобразование, он должен поднять ValueError, 
которая будет отловлена системой django, в таком случае система перейдет к проверке следующего варианта пути.

> Параметры пути не относятся к стандарту URL, в отличие от параметров url (query), которые обычно указываются после пути в виде `?key1=value1&key2=value2`

Пример создания и регистрации нового конвертера:
```Python
# converters.py
class FourDigitYearConverter:
    regex = "[0-9]{4}"

    def to_python(self, value):
        return int(value)

    def to_url(self, value):
        return "%04d" % value

# urls.py
from django.urls import path, register_converter

from . import views, converters

register_converter(converters.FourDigitYearConverter, "yyyy")

urlpatterns = [
    path("archive/<yyyy:year>/", views.year_archive),
]
```

В интерфейсе класса конвертера названия `regex`, `to_python` и `to_url` являются обязательными ключевыми словами.  
Исходный код конвертеров обычно располагается в отдельном файле, а регистрация конверторов проводится там же где и регистрация путей. 
При этом имя, под которым регистрируется конвертер, используется в шаблоне пути в угловых скобках через двоеточие перед именем параметра 
(иногда это выглядит как тип данных, но не является типом. конвертер по умочанию `str`).

> Таким образом, основная задача конвертеров -- распознать путь (маршрут), чтобы вызвать его обработчик, 
> и передать туда параметры пути в удобном для дальнейшей работы виде.
> Не следует в конвертере решать задачи обработчика, например пытаться поднять другие типы ошибок и или реализовать логику не относящуюся к преобразованию типов.

#### Применение конвертеров.
Допустим, в пути в качестве параметра используется дата. В джанго нет готовых конвереров для дат, поэтому задача распознания и преобразования такого параметра или пути может стать актуальной. Как её решить? Для начала ответить на вопросы "зачем нам нужна дата?", "в каком формате она приходит?", "к какому типу данных её удобнее преобразовать?". Например, могут возникнуть такие ситуации:

- Возможно, дату следует оставить строкой. Может это просто название директории в архиве со статическим контентом. Но если не будет проверки формата, следует убедиться что этот url путь нельзя перепутать с другими. А ещё подумать о безопасности: может кто-то так получит не авторизованный доступ к ресурсам, введя вместо даты путь к каталогу с системными файлами или конфиденциальной информацией.
- Если дату определенного формата из цифр надо преобразовать в целые числа и разделить на части, можно использовать встроенный `int` конвертер. Что, опять же, не застрахует от вызова обработчика для чисел неправильного диапазона. Впрочем, если вместо "not found" мы хотим вызвать обработчик и сообщить о неверном формате, то этот вариант может подойти.
- В некоторых случаях мы можем передать в обработчик слегка отфильтрованные строки, тогда можно использовтаь пути со встроенными regex параметрами, например `(?P<year>[0-9]{4})` пропустит только 4-значные натуральные числа (или 4-ре нуля), оставив их строкой. (в этом варианте весь путь указывается как регулярное выражение `r"^.../.../$"` и регистрируется как `re_path` вместо `path` объекта).
- Хорошим вариантом представляется специальный конвертер, который попробует преобразовать дату известного формата в datetime объект, с которым удобно работать в дальнейшем, в том чиле преобразовать к другому формату и выполнять сравнения и вычисления дат.
- Может так получится, что дату вовсе не следует передавать как часть пути, а лучше сделать параметром url query или json payload.


#### Литература:
[1] [Официальная документация (на английском)](https://docs.djangoproject.com/en/4.2/topics/http/urls/#path-converters)  
[2] [Довольно хорошая статья с примерами (на русском)](https://habr.com/ru/companies/yandex_praktikum/articles/541068/)

---


### Практическая задача:

- текст условия:  

Напишите код конвертора строки формата `'%Y-%m-%d'` в объект datetime.
Напишите код обработчика запросов который разрешает обработку дат начиная с 1900 года.
Расположите код конвертера и обработчика в том же файле, где производится регистраия маршрутов,  
и зарегистрируйте произвольный маршрут, использующий их.  

- прекод:  
```Python
from datetime import datetime
from django.urls import path, register_converter
from django.http import HttpResponse, HttpResponseNotFound


class DateConverter:
    regex = None

    def to_python(self, value):
        return

    def to_url(self, value):
        return


def process_dated_archive(request, date: datetime):
    return
```

- текст подсказки:  
```Python
# 1: regex = "[0-9]{4}-[0-9]{2}-[0-9]{2}"
# 2: format = '%Y-%m-%d'
# 3: return datetime.strptime(value, self.format)
# 4: return value.strftime(self.format)
# 5: if date >= datetime(1900,1,1):
# 6: register_converter(DateConverter, "datetime")
# 7: path("archive/<datetime:date>/", process_dated_archive),
```

- код авторского решения:  
```Python
# urls.py
from datetime import datetime
from django.urls import path, register_converter
from django.http import HttpResponse, HttpResponseNotFound


class DateConverter:
    regex = "[0-9]{4}-[0-9]{2}-[0-9]{2}"
    format = '%Y-%m-%d'

    def to_python(self, value: str) -> datetime:
        return datetime.strptime(value, self.format)

    def to_url(self, value: datetime) -> str:
        return value.strftime(self.format)


def process_dated_archive(request, date: datetime):
    if date >= datetime(1900,1,1):
        return HttpResponse("<h1>Page was found</h1>")
    else:
        return HttpResponseNotFound("<h1>Page not found</h1>")


register_converter(DateConverter, "datetime")

urlpatterns = [
    path("archive/<datetime:date>/", process_dated_archive, name="process_dated_archive_request"),
]
```

- текст сообщения, которое увидит студент после удачного решения задачи.  

Успех! Обратите внимание, что код логики обработки дат отделен от кода преобразования. Зачастую, в правльном выделении зон ответсвенности для исполнителей заключается ключ к успеху.

### Квиз:
(на понимание студентом теории из урока)

- вопрос
- варианты ответа
- комментарии к каждому варианту ответа, которые показываются студенту после решения квиза.

Q: что будет происходить если попробовать зарегистрировать два одинаковых маршрута?
A1: будет вызван обработчик для первого маршрута в списке
C1: верно. проверка первого маршрута окажется успешной, и до второго дело не дойдет.
A2: будет вызван обработчик для второго маршрута в списке
C2: не верно. маршруты не перезаписывают друг друга, а сохранюятся в порядке регистрации, и проверяются по очереди.
A3: будут вызваны оба обработчика по очереди.
C3: не верно. на каждый запрос вызывается только один обработчик, указанный в первом совпавшем маршруте.
A4: будет поднята ошибка о том что зарегистрированный маршрут уже есть в списке.
C4: не верно. маршруты не проверяются при регистрации.
